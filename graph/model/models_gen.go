// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	srvuser "quorum-api/services/user"
	"strconv"
)

type BaseError interface {
	IsBaseError()
	GetMessage() string
	GetPath() []string
}

type GetLoginLinkError interface {
	IsGetLoginLinkError()
}

type SignUpError interface {
	IsSignUpError()
}

type VerifyUserTokenError interface {
	IsVerifyUserTokenError()
}

type EmailTakenError struct {
	Message string   `json:"message"`
	Path    []string `json:"path,omitempty"`
}

func (EmailTakenError) IsBaseError()            {}
func (this EmailTakenError) GetMessage() string { return this.Message }
func (this EmailTakenError) GetPath() []string {
	if this.Path == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.Path))
	for _, concrete := range this.Path {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

func (EmailTakenError) IsSignUpError() {}

type GetLoginLinkInput struct {
	Email    string `json:"email"`
	ReturnTo string `json:"returnTo"`
}

type GetLoginLinkPayload struct {
	Errors []GetLoginLinkError `json:"errors"`
}

type InvalidEmailError struct {
	Message string   `json:"message"`
	Path    []string `json:"path,omitempty"`
}

func (InvalidEmailError) IsBaseError()            {}
func (this InvalidEmailError) GetMessage() string { return this.Message }
func (this InvalidEmailError) GetPath() []string {
	if this.Path == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.Path))
	for _, concrete := range this.Path {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

func (InvalidEmailError) IsSignUpError() {}

func (InvalidEmailError) IsGetLoginLinkError() {}

type InvalidReturnToError struct {
	Message string   `json:"message"`
	Path    []string `json:"path,omitempty"`
}

func (InvalidReturnToError) IsBaseError()            {}
func (this InvalidReturnToError) GetMessage() string { return this.Message }
func (this InvalidReturnToError) GetPath() []string {
	if this.Path == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.Path))
	for _, concrete := range this.Path {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

func (InvalidReturnToError) IsSignUpError() {}

func (InvalidReturnToError) IsGetLoginLinkError() {}

type LinkExpiredError struct {
	Message string   `json:"message"`
	Path    []string `json:"path,omitempty"`
}

func (LinkExpiredError) IsBaseError()            {}
func (this LinkExpiredError) GetMessage() string { return this.Message }
func (this LinkExpiredError) GetPath() []string {
	if this.Path == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.Path))
	for _, concrete := range this.Path {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

func (LinkExpiredError) IsVerifyUserTokenError() {}

type Mutation struct {
}

type Query struct {
}

type SignUpInput struct {
	FirstName  string         `json:"firstName"`
	LastName   string         `json:"lastName"`
	Email      string         `json:"email"`
	Profession UserProfession `json:"profession"`
	ReturnTo   string         `json:"returnTo"`
}

type SignUpPayload struct {
	Errors []SignUpError `json:"errors"`
}

type UserNotFoundError struct {
	Message string   `json:"message"`
	Path    []string `json:"path,omitempty"`
}

func (UserNotFoundError) IsBaseError()            {}
func (this UserNotFoundError) GetMessage() string { return this.Message }
func (this UserNotFoundError) GetPath() []string {
	if this.Path == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.Path))
	for _, concrete := range this.Path {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

func (UserNotFoundError) IsGetLoginLinkError() {}

type VerifyUserTokenInput struct {
	Token string `json:"token"`
}

type VerifyUserTokenPayload struct {
	User     *srvuser.User          `json:"user,omitempty"`
	NewToken *string                `json:"newToken,omitempty"`
	Errors   []VerifyUserTokenError `json:"errors"`
}

type UserProfession string

const (
	UserProfessionProductDesigner  UserProfession = "PRODUCT_DESIGNER"
	UserProfessionSoftwareEngineer UserProfession = "SOFTWARE_ENGINEER"
	UserProfessionOther            UserProfession = "OTHER"
)

var AllUserProfession = []UserProfession{
	UserProfessionProductDesigner,
	UserProfessionSoftwareEngineer,
	UserProfessionOther,
}

func (e UserProfession) IsValid() bool {
	switch e {
	case UserProfessionProductDesigner, UserProfessionSoftwareEngineer, UserProfessionOther:
		return true
	}
	return false
}

func (e UserProfession) String() string {
	return string(e)
}

func (e *UserProfession) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserProfession(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserProfession", str)
	}
	return nil
}

func (e UserProfession) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
